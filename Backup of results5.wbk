Project #4 Results
Due: 6/25/17
Thurston Brevett
Pooja Jhaveri

This project required writing local search algorithms to find better solutions for the Knapsack and Graph Coloring optimization problems.

For Graph Coloring steepest descent was implemented by using the greedy algorithm as an initial solution and defining the neighborhood by swapping the colors of adjacent nodes. We found that the greedy algorithm already gave us locally optimal solutions since the steepest descent algorithm was not able to provide more optimal results. We also ran local search with the exhaustive algorithm (run for one minute) as the initial solution. In this case we found that steepest descent was successfully able to produce locally optimal results.

The advanced algorithm we implemented for graph coloring was simulated annealing. We used both greedy and exhaustive approaches for initial solutions in this case as well. We found that in some cases the end result was less optimal than the initial solution because of the nature of simulated annealing; depending on probability, it is possible to accept a less optimal neighbor than the current solution. 

Output files for all of these cases as well as log files are included in the submission

For Knapsack, steepest descent was implemented by using the greedy algorithm as an initial solution, and defining a large neighborhood around the solution. The neighborhood is a type of 3-opt; if adding an item produced a legal solution, that solution is in the neighborhood, if that option was not a legal solution, then if after removing an item the solution was legal, then that option was in the neighborhood. Finally, if after adding and removing an item, the knapsack is still legal, if adding a third item produces a legal solution, that item is in the neighborhood. With this limited 3-opt, we had a compromise between reaching far into the surrounding neighborhood and reserving computations in order to make more steps. This method generally produced results that were more optimal than the greedy algorithm alone for small problems, but struggled with time to optimize for large problems.

The advanced algorithm we choose for Knapsack was the genetic algorithm. Our population included 10 knapsacks, 1 of which was the greedy algorithm solution, and the rest of which were randomly generated. On each iteration, the knapsacks were sorted by total value and “mated” with both adjacent solutions (which may or may not have been legal) producing a population roughly twice the original size. Afterwards, all of the illegal solutions and worse solutions are removed until only half the original population remains. Then the population is brought back up to size by introducing 5 more random knapsacks. The best legal knapsack by the end of runtime is given as the solution. Similarly, this algorithm produced more optimal results for smaller cases, but struggled with compute time for large cases.

In summary, the local search algorithms developed for this project were able to produce more optimal results compared to the greedy algorithm benchmark, but for large cases, a large amount of runtime was needed to optimize the answer.
